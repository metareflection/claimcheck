// Generated by claimcheck — obligations to be discharged
// 2 requirement(s) could not be automatically verified
// Prove these lemmas or refine the requirements

include "../../../../dafny-replay/canon/CanonDomain.dfy"

module Obligations {
  import D = CanonDomain

  // Requirement: "Removing a node cleans up related constraints and edges"
  // Status: unproven after 4 attempt(s)
  // Strategies: direct✗ → llm-guided✗ → retry✗ → retry✗
  // Reasoning: The previous error showed that 'nodes' is not a nested structure with a 'nodes' field, but rather is itself the collection of nodes (of type Axis which contains the node collection). The fix is to check 'nodeId !in nodes' directly instead of 'nodeId !in nodes.nodes'. The lemma states that after removing a node, (1) no edges reference it, (2) no constraints reference it, and (3) it's not in the model's nodes. This should follow from the RemoveNode operation definition and the RemoveNodePreservesInv lemma.
  // Last error:
  //   /var/folders/3d/zmzv6_gs7zv67pg3stcgb37m0000gr/T/claimcheck-OyzbhJ/verify.dfy(15,55): Error: second argument to "!in" must be a set, multiset, or sequence with elements of type D.C.NodeId, or a map with domain D.C.NodeId (instead got Axis)
  //      |
  //   15 |               case Align(dir, offset, nodes) => nodeId !in nodes
  //
  // Best attempt:
  // lemma RemoveNodeCleansUpRelatedConstraintsAndEdges(m: D.Model, nodeId: D.C.NodeId)
  //   requires D.Inv(m)
  //   ensures var m' := D.Apply(m, D.RemoveNode(nodeId));
  //           // No edges reference the removed node
  //           (forall e | e in m'.edges :: e.from != nodeId && e.to != nodeId)
  //           &&
  //           // No constraints reference the removed node
  //           (forall c | c in m'.constraints ::
  //             match c
  //               case Align(dir, offset, nodes) => nodeId !in nodes
  //               case EvenSpace(dir, spacing, nodes) => nodeId !in nodes)
  //           &&
  //           // The node is no longer in the model
  //           nodeId !in m'.nodes
  // {
  //   var m' := D.Apply(m, D.RemoveNode(nodeId));
  //   D.C.RemoveNodePreservesInv(m, nodeId);
  // }

  lemma RemoveNodeCleansUpRelatedConstraintsAndEdges(m: D.Model, nodeId: D.C.NodeId)
  requires D.Inv(m)
  ensures var m' := D.Apply(m, D.RemoveNode(nodeId));
          // No edges reference the removed node
          (forall e | e in m'.edges :: e.from != nodeId && e.to != nodeId)
          &&
          // No constraints reference the removed node
          (forall c | c in m'.constraints ::
            match c
              case Align(dir, offset, nodes) => nodeId !in nodes
              case EvenSpace(dir, spacing, nodes) => nodeId !in nodes)
          &&
          // The node is no longer in the model
          nodeId !in m'.nodes
{
  var m' := D.Apply(m, D.RemoveNode(nodeId));
  D.C.RemoveNodePreservesInv(m, nodeId);
}

  // Requirement: "The constraint ID allocator is always fresh"
  // Status: unproven after 4 attempt(s)
  // Strategies: direct✗ → llm-guided✗ → retry✗ → retry✗
  // Reasoning: The lemma attempts to prove that all constraint IDs in the model are less than nextCid (i.e., the allocator is fresh). The previous attempt with reveal D.Inv() failed, suggesting that either the invariant doesn't contain this property or it needs more explicit proof steps. This version uses a forall statement to explicitly iterate over constraints and establish the property for each one. If this still fails, it likely means the D.Inv() predicate doesn't actually guarantee constraint ID freshness, in which case the requirement cannot be proven from the invariant alone.
  // Last error:
  //   /var/folders/3d/zmzv6_gs7zv67pg3stcgb37m0000gr/T/claimcheck-RhfguL/verify.dfy(17,18): Error: possible violation of postcondition of forall statement
  //      |
  //   17 |     ensures c.cid < m.nextCid
  //
  // Best attempt:
  // lemma ConstraintIdAllocatorIsAlwaysFresh(m: D.Model)
  //   requires D.Inv(m)
  //   ensures forall c | c in m.constraints :: c.cid < m.nextCid
  // {
  //   // The invariant D.Inv(m) should include a property about constraint IDs
  //   // We need to assert the invariant explicitly to help Dafny see the connection
  //   assert D.Inv(m);
  //   
  //   // If the invariant contains a conjunct about constraint freshness,
  //   // we may need to help Dafny unfold it
  //   forall c | c in m.constraints
  //     ensures c.cid < m.nextCid
  //   {
  //     // The invariant should guarantee this property
  //     // If it doesn't verify, the invariant may not contain this constraint
  //   }
  // }

  lemma ConstraintIdAllocatorIsAlwaysFresh(m: D.Model)
  requires D.Inv(m)
  ensures forall c | c in m.constraints :: c.cid < m.nextCid
{
  // The invariant D.Inv(m) should include a property about constraint IDs
  // We need to assert the invariant explicitly to help Dafny see the connection
  assert D.Inv(m);
  
  // If the invariant contains a conjunct about constraint freshness,
  // we may need to help Dafny unfold it
  forall c | c in m.constraints
    ensures c.cid < m.nextCid
  {
    // The invariant should guarantee this property
    // If it doesn't verify, the invariant may not contain this constraint
  }
}

}