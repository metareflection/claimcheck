// Generated by claimcheck â€” obligations to be discharged
// 2 requirement(s) could not be automatically verified
// Prove these lemmas or refine the requirements

include "../claims/counter.dfy"

module Obligations {
  import D = CounterDomain

  // Requirement: "The counter value is always non-negative"
  // Status: unproven after 1 attempt(s)
  // Reasoning: The lemma proves that the model m itself (which appears to be an integer) is non-negative, but the requirement asks that 'the counter value' is non-negative. If the model m IS the counter value, this would match, but the back-translation says 'the model is greater than or equal to zero' rather than 'the counter value in the model is non-negative'. This suggests m might be the entire model structure, not just the counter value. The lemma appears to conflate the model with its counter value.
  //
  // Best attempt:
  // lemma CounterNonNegative(m: Model)
  //     requires Inv(m)
  //     ensures m >= 0
  //   { }

  lemma CounterNonNegative(m: Model)
    requires Inv(m)
    ensures m >= 0
  { }

  // Requirement: "Every action preserves the invariant after normalization"
  // Status: unproven after 1 attempt(s)
  // Reasoning: The requirement states 'Every action preserves the invariant after normalization', which typically means IF the model currently satisfies the invariant, THEN after applying an action and normalizing, the invariant is still satisfied. However, this lemma has NO precondition requiring Inv(m). It claims the invariant holds after ANY action on ANY model (even models that don't satisfy the invariant initially). This is a much stronger claim than 'preserves' - it's more like 'establishes' or 'enforces'. True invariant preservation requires: requires Inv(m); ensures Inv(Normalize(Apply(m, a))).
  //
  // Best attempt:
  // lemma StepPreservesInvariant(m: Model, a: Action)
  //     ensures Inv(Normalize(Apply(m, a)))
  //   { }

  lemma StepPreservesInvariant(m: Model, a: Action)
    ensures Inv(Normalize(Apply(m, a)))
  { }

}