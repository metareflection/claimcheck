// Generated by claimcheck — obligations to be discharged
// 1 requirement(s) could not be automatically verified
// Prove these lemmas or refine the requirements

include "../../../../dafny-replay/kanban/KanbanDomain.dfy"

module Obligations {
  import D = KanbanDomain

  // Requirement: "Moving a card preserves the total number of cards"
  // Status: unproven after 4 attempt(s)
  // Strategies: direct✗ → llm-guided✗ → retry✗ → retry✗
  // Reasoning: The previous lemma failed because it directly asserted multiset properties about RemoveFirst and InsertAt without providing proof. The issue is that Dafny needs helper lemmas that explicitly prove these multiset properties. The fixed version:

1. Calls D.RemoveFirstMultisetLemma and D.InsertAtMultisetLemma to establish the multiset preservation properties
2. These helper lemmas should be defined in the domain to prove that RemoveFirst(s, id) results in multiset(s) - multiset{id}, and InsertAt(s, k, id) results in multiset(s) + multiset{id}
3. After establishing these properties, the reasoning about AllIds preservation follows from the FlattenColsSameColReorder and FlattenColsCrossColMove helper lemmas

If these helper lemmas don't exist in the domain, the lemma may still fail, but this approach correctly structures the proof by relying on the necessary supporting lemmas rather than asserting unproven multiset properties.
  // Last error:
  //   /var/folders/3d/zmzv6_gs7zv67pg3stcgb37m0000gr/T/claimcheck-6zqI4V/verify.dfy(30,8): Error: unresolved identifier: RemoveFirstMultisetLemma
  //      |
  //   30 |       D.RemoveFirstMultisetLemma(s, id);
  //
  // Best attempt:
  // lemma MoveCardPreservesTotalCards(m: D.Model, id: D.CardId, toCol: D.ColId, pos: int)
  //   requires D.Inv(m)
  //   ensures |D.AllIds(D.Normalize(D.Apply(m, D.MoveCard(id, toCol, pos))))| == |D.AllIds(m)|
  // {
  //   var m' := D.Apply(m, D.MoveCard(id, toCol, pos));
  //   assert D.Normalize(m') == m';
  //   
  //   if !(toCol in m.cols) || !(id in m.cards) {
  //     // No-op cases - model unchanged
  //     assert m' == m;
  //   } else {
  //     D.FindColumnOfInv(m, id);
  //     var src := D.FindColumnOf(m.cols, m.lanes, id);
  //     if src == "" {
  //       // Card not in any lane, no-op
  //       assert m' == m;
  //     } else if src == toCol {
  //       // Same-column reorder
  //       var s := D.Lane(m.lanes, src);
  //       var s1 := D.RemoveFirst(s, id);
  //       var k := D.ClampPos(pos, |s1|);
  //       var newLane := D.InsertAt(s1, k, id);
  //       
  //       // Need to establish multiset preservation via helper lemmas about RemoveFirst and InsertAt
  //       D.RemoveFirstMultisetLemma(s, id);
  //       D.InsertAtMultisetLemma(s1, k, id);
  //       
  //       // Now we can reason about multisets
  //       assert multiset(newLane) == multiset(s);
  //       
  //       // Use the helper lemma to prove AllIds is preserved
  //       D.FlattenColsSameColReorder(m.cols, m.lanes, src, id, k);
  //     } else {
  //       // Cross-column move
  //       if |D.Lane(m.lanes, toCol)| + 1 > D.Wip(m.wip, toCol) {
  //         // WIP limit exceeded, no-op
  //         assert m' == m;
  //       } else {
  //         var s := D.Lane(m.lanes, src);
  //         var t := D.Lane(m.lanes, toCol);
  //         var k := D.ClampPos(pos, |t|);
  //         
  //         var s1 := D.RemoveFirst(s, id);
  //         var newTarget := D.InsertAt(t, k, id);
  //         
  //         // Establish multiset properties for the transformations
  //         D.RemoveFirstMultisetLemma(s, id);
  //         D.InsertAtMultisetLemma(t, k, id);
  //         
  //         // Use the helper lemma for cross-column moves
  //         D.FlattenColsCrossColMove(m.cols, m.lanes, src, toCol, id, k);
  //       }
  //     }
  //   }
  // }

  lemma MoveCardPreservesTotalCards(m: D.Model, id: D.CardId, toCol: D.ColId, pos: int)
  requires D.Inv(m)
  ensures |D.AllIds(D.Normalize(D.Apply(m, D.MoveCard(id, toCol, pos))))| == |D.AllIds(m)|
{
  var m' := D.Apply(m, D.MoveCard(id, toCol, pos));
  assert D.Normalize(m') == m';
  
  if !(toCol in m.cols) || !(id in m.cards) {
    // No-op cases - model unchanged
    assert m' == m;
  } else {
    D.FindColumnOfInv(m, id);
    var src := D.FindColumnOf(m.cols, m.lanes, id);
    if src == "" {
      // Card not in any lane, no-op
      assert m' == m;
    } else if src == toCol {
      // Same-column reorder
      var s := D.Lane(m.lanes, src);
      var s1 := D.RemoveFirst(s, id);
      var k := D.ClampPos(pos, |s1|);
      var newLane := D.InsertAt(s1, k, id);
      
      // Need to establish multiset preservation via helper lemmas about RemoveFirst and InsertAt
      D.RemoveFirstMultisetLemma(s, id);
      D.InsertAtMultisetLemma(s1, k, id);
      
      // Now we can reason about multisets
      assert multiset(newLane) == multiset(s);
      
      // Use the helper lemma to prove AllIds is preserved
      D.FlattenColsSameColReorder(m.cols, m.lanes, src, id, k);
    } else {
      // Cross-column move
      if |D.Lane(m.lanes, toCol)| + 1 > D.Wip(m.wip, toCol) {
        // WIP limit exceeded, no-op
        assert m' == m;
      } else {
        var s := D.Lane(m.lanes, src);
        var t := D.Lane(m.lanes, toCol);
        var k := D.ClampPos(pos, |t|);
        
        var s1 := D.RemoveFirst(s, id);
        var newTarget := D.InsertAt(t, k, id);
        
        // Establish multiset properties for the transformations
        D.RemoveFirstMultisetLemma(s, id);
        D.InsertAtMultisetLemma(t, k, id);
        
        // Use the helper lemma for cross-column moves
        D.FlattenColsCrossColMove(m.cols, m.lanes, src, toCol, id, k);
      }
    }
  }
}

}