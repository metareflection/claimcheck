{
  "proved": [
    {
      "claimId": "pred:Canon.Inv:0",
      "naturalLanguage": "All constraints in the model are valid with respect to the nodes.",
      "matchedRequirement": "All constraint targets reference existing nodes",
      "explanation": "This claim directly ensures that constraints are valid with respect to nodes, which means constraint targets must reference existing nodes."
    },
    {
      "claimId": "pred:Canon.Inv:1",
      "naturalLanguage": "All edges in the model are valid with respect to the nodes.",
      "matchedRequirement": "All edge endpoints reference existing nodes",
      "explanation": "This claim directly ensures that edges are valid with respect to nodes, which means edge endpoints must reference existing nodes."
    }
  ],
  "missing": [
    {
      "requirement": "Adding a node with an existing ID is a no-op",
      "explanation": "While there is a proof that AddNodeImpl preserves the invariant, there is no explicit proof that adding a node with an existing ID has no effect (is a no-op). The preservation of invariant doesn't guarantee this specific behavior."
    },
    {
      "requirement": "Removing a node cleans up related constraints and edges",
      "explanation": "There are no proofs related to removing nodes at all. The proved claims only cover adding nodes and moving nodes, but not node removal operations."
    },
    {
      "requirement": "The constraint ID allocator is always fresh",
      "explanation": "There are no proofs about constraint ID allocation or freshness guarantees. This requirement is completely unaddressed by the proved claims."
    }
  ],
  "unexpected": [
    {
      "claimId": "lemma:CanonDomain.AddNodeImplPreservesInv:ensures:0",
      "naturalLanguage": "The model invariant holds after adding a node with the given identifier and coordinates to a model that initially satisfies the invariant.",
      "explanation": "This is an invariant preservation property for adding nodes, but it doesn't directly match any stated requirement. It ensures safety but doesn't address the specific behavioral requirement about duplicate IDs being a no-op."
    },
    {
      "claimId": "lemma:CanonDomain.MoveNodeImplPreservesInv:ensures:0",
      "naturalLanguage": "The model invariant holds after moving a node to new coordinates in a model that initially satisfies the invariant.",
      "explanation": "This is an invariant preservation property for moving nodes, which is not mentioned in any of the user requirements."
    },
    {
      "claimId": "lemma:CanonDomain.InitSatisfiesInv:ensures:0",
      "naturalLanguage": "The initial state satisfies the model invariant.",
      "explanation": "This proves that initialization satisfies the invariant, but there is no requirement about initialization or initial state properties."
    },
    {
      "claimId": "lemma:CanonDomain.StepPreservesInv:ensures:0",
      "naturalLanguage": "The model invariant holds after applying an action to a model that satisfies the invariant and then normalizing the result.",
      "explanation": "This is a general invariant preservation property for all actions, but it doesn't match any specific user requirement. It's a proof engineering artifact rather than a stated requirement."
    },
    {
      "claimId": "fn:CanonDomain.Apply:requires:0",
      "naturalLanguage": "The model must satisfy the invariant for the Apply function to be called.",
      "explanation": "This is a precondition for the Apply function, which is a proof engineering detail rather than a user requirement."
    }
  ],
  "summary": "Coverage is partial. Only 2 out of 5 user requirements are formally proved (constraint and edge validity). Critical requirements about node ID uniqueness handling, node removal cleanup, and constraint ID freshness are completely missing. Most proved claims are invariant preservation lemmas that don't directly correspond to stated requirements."
}