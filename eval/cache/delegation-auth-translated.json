[
  {
    "id": "pred:DelegationAuthDomain.Inv:0",
    "kind": "invariant-conjunct",
    "formalText": "forall sc: (Subject, Capability) {:trigger sc.0} {:trigger sc in m.grants} :: sc in m.grants ==> sc.0 in m.subjects",
    "context": {
      "predicateName": "Inv",
      "module": "DelegationAuthDomain",
      "fullBody": "(forall sc: (Subject, Capability) {:trigger sc.0} {:trigger sc in m.grants} :: sc in m.grants ==> sc.0 in m.subjects) && (forall eid: int {:trigger m.delegations[eid]} {:trigger eid in m.delegations} :: (eid in m.delegations ==> m.delegations[eid].from in m.subjects) && (eid in m.delegations ==> m.delegations[eid].to in m.subjects)) && forall eid: int {:trigger eid in m.delegations} :: eid in m.delegations ==> eid < m.nextEdge",
      "line": 30
    },
    "naturalLanguage": "For all pairs of a subject and capability, if that pair is in the grants collection, then the subject must be in the subjects collection.",
    "confidence": 0.95
  },
  {
    "id": "pred:DelegationAuthDomain.Inv:1",
    "kind": "invariant-conjunct",
    "formalText": "forall eid: int {:trigger m.delegations[eid]} {:trigger eid in m.delegations} :: (eid in m.delegations ==> m.delegations[eid].from in m.subjects) && (eid in m.delegations ==> m.delegations[eid].to in m.subjects)",
    "context": {
      "predicateName": "Inv",
      "module": "DelegationAuthDomain",
      "fullBody": "(forall sc: (Subject, Capability) {:trigger sc.0} {:trigger sc in m.grants} :: sc in m.grants ==> sc.0 in m.subjects) && (forall eid: int {:trigger m.delegations[eid]} {:trigger eid in m.delegations} :: (eid in m.delegations ==> m.delegations[eid].from in m.subjects) && (eid in m.delegations ==> m.delegations[eid].to in m.subjects)) && forall eid: int {:trigger eid in m.delegations} :: eid in m.delegations ==> eid < m.nextEdge",
      "line": 30
    },
    "naturalLanguage": "For all edge identifiers, if the edge identifier is in the delegations collection, then both the source subject and target subject of that delegation must be in the subjects collection.",
    "confidence": 0.95
  },
  {
    "id": "pred:DelegationAuthDomain.Inv:2",
    "kind": "invariant-conjunct",
    "formalText": "forall eid: int {:trigger eid in m.delegations} :: eid in m.delegations ==> eid < m.nextEdge",
    "context": {
      "predicateName": "Inv",
      "module": "DelegationAuthDomain",
      "fullBody": "(forall sc: (Subject, Capability) {:trigger sc.0} {:trigger sc in m.grants} :: sc in m.grants ==> sc.0 in m.subjects) && (forall eid: int {:trigger m.delegations[eid]} {:trigger eid in m.delegations} :: (eid in m.delegations ==> m.delegations[eid].from in m.subjects) && (eid in m.delegations ==> m.delegations[eid].to in m.subjects)) && forall eid: int {:trigger eid in m.delegations} :: eid in m.delegations ==> eid < m.nextEdge",
      "line": 30
    },
    "naturalLanguage": "For all edge identifiers, if the edge identifier is in the delegations collection, then the edge identifier must be less than the next available edge identifier.",
    "confidence": 0.96
  },
  {
    "id": "pred:DelegationAuthDomain.DerivableN:0",
    "kind": "invariant-conjunct",
    "formalText": "if n == 0 then (s, cap) in m.grants else DerivableN(m, s, cap, n - 1) || exists eid: int {:trigger m.delegations[eid]} {:trigger eid in m.delegations} :: eid in m.delegations && m.delegations[eid].cap == cap && m.delegations[eid].to == s && DerivableN(m, m.delegations[eid].from, cap, n - 1)",
    "context": {
      "predicateName": "DerivableN",
      "module": "DelegationAuthDomain",
      "fullBody": "if n == 0 then (s, cap) in m.grants else DerivableN(m, s, cap, n - 1) || exists eid: int {:trigger m.delegations[eid]} {:trigger eid in m.delegations} :: eid in m.delegations && m.delegations[eid].cap == cap && m.delegations[eid].to == s && DerivableN(m, m.delegations[eid].from, cap, n - 1)",
      "line": 127
    },
    "naturalLanguage": "A capability is derivable for a subject in zero steps if and only if the subject-capability pair is in the grants collection, or the capability is derivable for the subject in one fewer step, or there exists a delegation where the capability matches, the target is the subject, and the capability is derivable for the delegation's source subject in one fewer step.",
    "confidence": 0.92
  },
  {
    "id": "pred:DelegationAuthDomain.HasCap:0",
    "kind": "invariant-conjunct",
    "formalText": "exists n: nat {:trigger DerivableN(m, s, cap, n)} :: n <= |m.subjects| && DerivableN(m, s, cap, n)",
    "context": {
      "predicateName": "HasCap",
      "module": "DelegationAuthDomain",
      "fullBody": "exists n: nat {:trigger DerivableN(m, s, cap, n)} :: n <= |m.subjects| && DerivableN(m, s, cap, n)",
      "line": 140
    },
    "naturalLanguage": "There exists a natural number not exceeding the number of subjects such that the capability is derivable for the subject in that many steps.",
    "confidence": 0.94
  },
  {
    "id": "lemma:DelegationAuthDomain.ReachCorrect:ensures:0",
    "kind": "lemma-ensures",
    "formalText": "s in Reach(m, cap) <==> HasCap(m, s, cap)",
    "context": {
      "lemmaName": "ReachCorrect",
      "module": "DelegationAuthDomain",
      "requires": [
        "Inv(m)"
      ],
      "allEnsures": [
        "s in Reach(m, cap) <==> HasCap(m, s, cap)"
      ],
      "line": 146
    },
    "naturalLanguage": "A subject is in the reachable set for a capability if and only if the subject has the capability.",
    "confidence": 0.96
  },
  {
    "id": "lemma:DelegationAuthDomain.ReachNMonotone:ensures:0",
    "kind": "lemma-ensures",
    "formalText": "ReachN(m, cap, n) <= ReachN(m, cap, n + 1)",
    "context": {
      "lemmaName": "ReachNMonotone",
      "module": "DelegationAuthDomain",
      "requires": [],
      "allEnsures": [
        "ReachN(m, cap, n) <= ReachN(m, cap, n + 1)"
      ],
      "line": 169
    },
    "naturalLanguage": "The set of subjects reachable in n steps for a capability is a subset of the set of subjects reachable in n plus one steps for that capability.",
    "confidence": 0.95
  },
  {
    "id": "lemma:DelegationAuthDomain.InitSatisfiesInv:ensures:0",
    "kind": "lemma-ensures",
    "formalText": "Inv(Init())",
    "context": {
      "lemmaName": "InitSatisfiesInv",
      "module": "DelegationAuthDomain",
      "requires": [],
      "allEnsures": [
        "Inv(Init())",
        "Inv(Init())"
      ],
      "line": 177
    },
    "naturalLanguage": "The initial state satisfies the invariant.",
    "confidence": 0.98
  },
  {
    "id": "lemma:DelegationAuthDomain.StepPreservesInv:ensures:0",
    "kind": "lemma-ensures",
    "formalText": "Inv(Normalize(Apply(m, a)))",
    "context": {
      "lemmaName": "StepPreservesInv",
      "module": "DelegationAuthDomain",
      "requires": [
        "Inv(m)"
      ],
      "allEnsures": [
        "Inv(Normalize(Apply(m, a)))"
      ],
      "line": 182
    },
    "naturalLanguage": "If the invariant holds for a state, then the invariant holds for the normalized state resulting from applying an action to that state.",
    "confidence": 0.94
  },
  {
    "id": "lemma:DelegationAuthDomain.ReachNImpliesDerivableN:ensures:0",
    "kind": "lemma-ensures",
    "formalText": "DerivableN(m, s, cap, n)",
    "context": {
      "lemmaName": "ReachNImpliesDerivableN",
      "module": "DelegationAuthDomain",
      "requires": [
        "Inv(m)",
        "s in ReachN(m, cap, n)"
      ],
      "allEnsures": [
        "DerivableN(m, s, cap, n)"
      ],
      "line": 190
    },
    "naturalLanguage": "If the invariant holds and a subject is in the reachable set for a capability in n steps, then the capability is derivable for that subject in n steps.",
    "confidence": 0.93
  },
  {
    "id": "lemma:DelegationAuthDomain.DerivableNImpliesReachN:ensures:0",
    "kind": "lemma-ensures",
    "formalText": "s in ReachN(m, cap, n)",
    "context": {
      "lemmaName": "DerivableNImpliesReachN",
      "module": "DelegationAuthDomain",
      "requires": [
        "Inv(m)",
        "DerivableN(m, s, cap, n)"
      ],
      "allEnsures": [
        "s in ReachN(m, cap, n)"
      ],
      "line": 214
    },
    "naturalLanguage": "Given that the delegation model is in a valid state and the subject is derivable within n steps to the capability, the subject is reachable within n steps to the capability.",
    "confidence": 0.92
  },
  {
    "id": "lemma:DelegationAuthDomain.ReachNEquivDerivableN:ensures:0",
    "kind": "lemma-ensures",
    "formalText": "s in ReachN(m, cap, n) <==> DerivableN(m, s, cap, n)",
    "context": {
      "lemmaName": "ReachNEquivDerivableN",
      "module": "DelegationAuthDomain",
      "requires": [
        "Inv(m)"
      ],
      "allEnsures": [
        "s in ReachN(m, cap, n) <==> DerivableN(m, s, cap, n)"
      ],
      "line": 239
    },
    "naturalLanguage": "Given that the delegation model is in a valid state, a subject is reachable within n steps to a capability if and only if the subject is derivable within n steps to that capability.",
    "confidence": 0.93
  },
  {
    "id": "lemma:DelegationAuthDomain.ReachNMonotoneGeneral:ensures:0",
    "kind": "lemma-ensures",
    "formalText": "ReachN(m, cap, n) <= ReachN(m, cap, k)",
    "context": {
      "lemmaName": "ReachNMonotoneGeneral",
      "module": "DelegationAuthDomain",
      "requires": [
        "n <= k"
      ],
      "allEnsures": [
        "ReachN(m, cap, n) <= ReachN(m, cap, k)"
      ],
      "line": 251
    },
    "naturalLanguage": "If n is less than or equal to k, then the set of subjects reachable within n steps to a capability is a subset of the set of subjects reachable within k steps to that capability.",
    "confidence": 0.94
  },
  {
    "id": "fn:DelegationAuthDomain.Apply:requires:0",
    "kind": "function-precondition",
    "formalText": "Inv(m)",
    "context": {
      "functionName": "Apply",
      "module": "DelegationAuthDomain",
      "line": 53
    },
    "naturalLanguage": "The delegation model must be in a valid state.",
    "confidence": 0.95
  }
]