{
  "proved": [
    {
      "claimId": "pred:DelegationAuthDomain.Inv:0",
      "naturalLanguage": "For all pairs of a subject and capability, if that pair is in the grants collection, then the subject must be in the subjects collection.",
      "matchedRequirement": "All granted capabilities reference existing subjects",
      "explanation": "This claim directly proves that every grant in the system references a subject that exists in the subjects collection, which is exactly what requirement 1 states."
    },
    {
      "claimId": "pred:DelegationAuthDomain.Inv:1",
      "naturalLanguage": "For all edge identifiers, if the edge identifier is in the delegations collection, then both the source subject and target subject of that delegation must be in the subjects collection.",
      "matchedRequirement": "Delegation endpoints (from, to) must be existing subjects",
      "explanation": "This claim proves that both the 'from' and 'to' subjects of any delegation must exist in the subjects collection, which is exactly requirement 2."
    },
    {
      "claimId": "pred:DelegationAuthDomain.Inv:2",
      "naturalLanguage": "For all edge identifiers, if the edge identifier is in the delegations collection, then the edge identifier must be less than the next available edge identifier.",
      "matchedRequirement": "Edge IDs are always less than the next allocator (freshness)",
      "explanation": "This claim proves that all edge IDs in the delegations collection are strictly less than nextEdge, ensuring freshness of the edge ID allocator, which directly corresponds to requirement 3."
    },
    {
      "claimId": "lemma:DelegationAuthDomain.StepPreservesInv:ensures:0",
      "naturalLanguage": "If the invariant holds for a state, then the invariant holds for the normalized state resulting from applying an action to that state.",
      "matchedRequirement": "Granting a capability to a non-existent subject is a no-op",
      "explanation": "This lemma proves that the invariant is preserved after any action. Since Inv:0 states that all grants must reference existing subjects, and this lemma proves the invariant is maintained, it implies that attempting to grant to a non-existent subject cannot violate the invariant, effectively making it a no-op. This is the closest proof for requirement 4, though it's an indirect match through invariant preservation."
    }
  ],
  "missing": [
    {
      "requirement": "Delegating between non-existent subjects is a no-op",
      "explanation": "While StepPreservesInv implies that invariants are maintained (including that delegation endpoints must exist), there is no explicit proof that delegating between non-existent subjects is specifically a no-op. The proved claim about invariant preservation is already matched to requirement 4, and this requirement needs its own explicit verification."
    },
    {
      "requirement": "Revoking a non-existent delegation is a no-op",
      "explanation": "There is no formal claim that explicitly proves revocation of a non-existent delegation has no effect. While invariant preservation is proved, there's no specific claim about the revoke operation's behavior on non-existent delegations."
    }
  ],
  "unexpected": [
    {
      "claimId": "pred:DelegationAuthDomain.DerivableN:0",
      "naturalLanguage": "A capability is derivable for a subject in zero steps if and only if the subject-capability pair is in the grants collection, or the capability is derivable for the subject in one fewer step, or there exists a delegation where the capability matches, the target is the subject, and the capability is derivable for the delegation's source subject in one fewer step.",
      "explanation": "This defines the recursive derivability predicate for capabilities through delegation chains, but does not correspond to any stated user requirement. It's a helper predicate for reasoning about the system."
    },
    {
      "claimId": "pred:DelegationAuthDomain.HasCap:0",
      "naturalLanguage": "There exists a natural number not exceeding the number of subjects such that the capability is derivable for the subject in that many steps.",
      "explanation": "This defines when a subject has a capability through bounded derivation, but is not mentioned in any user requirement. It's a specification construct rather than a user-facing requirement."
    },
    {
      "claimId": "lemma:DelegationAuthDomain.ReachCorrect:ensures:0",
      "naturalLanguage": "A subject is in the reachable set for a capability if and only if the subject has the capability.",
      "explanation": "This proves the correctness of the reachability computation, establishing equivalence between two different formulations. This is not mentioned in any user requirement."
    },
    {
      "claimId": "lemma:DelegationAuthDomain.ReachNMonotone:ensures:0",
      "naturalLanguage": "The set of subjects reachable in n steps for a capability is a subset of the set of subjects reachable in n plus one steps for that capability.",
      "explanation": "This proves monotonicity of reachability with respect to step count, which is not a stated user requirement. It's a useful property for reasoning but not explicitly requested."
    },
    {
      "claimId": "lemma:DelegationAuthDomain.InitSatisfiesInv:ensures:0",
      "naturalLanguage": "The initial state satisfies the invariant.",
      "explanation": "This proves the invariant holds initially, which is not explicitly mentioned in the user requirements. While important for system correctness, it wasn't specifically requested."
    },
    {
      "claimId": "lemma:DelegationAuthDomain.ReachNImpliesDerivableN:ensures:0",
      "naturalLanguage": "If the invariant holds and a subject is in the reachable set for a capability in n steps, then the capability is derivable for that subject in n steps.",
      "explanation": "This proves one direction of equivalence between reachability and derivability, not mentioned in user requirements."
    },
    {
      "claimId": "lemma:DelegationAuthDomain.DerivableNImpliesReachN:ensures:0",
      "naturalLanguage": "Given that the delegation model is in a valid state and the subject is derivable within n steps to the capability, the subject is reachable within n steps to the capability.",
      "explanation": "This proves the other direction of equivalence between derivability and reachability, not mentioned in user requirements."
    },
    {
      "claimId": "lemma:DelegationAuthDomain.ReachNEquivDerivableN:ensures:0",
      "naturalLanguage": "Given that the delegation model is in a valid state, a subject is reachable within n steps to a capability if and only if the subject is derivable within n steps to that capability.",
      "explanation": "This proves full equivalence between reachability and derivability at n steps, which is not a stated user requirement. It's a technical property for reasoning about the system."
    },
    {
      "claimId": "lemma:DelegationAuthDomain.ReachNMonotoneGeneral:ensures:0",
      "naturalLanguage": "If n is less than or equal to k, then the set of subjects reachable within n steps to a capability is a subset of the set of subjects reachable within k steps to that capability.",
      "explanation": "This generalizes the monotonicity property for any n and k, not mentioned in user requirements."
    },
    {
      "claimId": "fn:DelegationAuthDomain.Apply:requires:0",
      "naturalLanguage": "The delegation model must be in a valid state.",
      "explanation": "This is a precondition for the Apply function, ensuring operations are only applied to valid states. It's not a user requirement but rather a proof obligation/API contract."
    }
  ],
  "summary": "The formal verification covers the three core invariant requirements (1-3) directly and provides some coverage for requirement 4 through invariant preservation. However, requirements 5 and 6 about no-op behavior for delegating between non-existent subjects and revoking non-existent delegations lack explicit proofs. Many additional technical properties about reachability, derivability, and their equivalence have been proved but were not explicitly requested by the user."
}