{
  "domain": "election",
  "timestamp": "2026-02-15T16:59:55.245Z",
  "results": [
    {
      "requirement": "No candidate can receive more votes than the total number of ballots cast",
      "lemmaName": "CountBounded",
      "status": "confirmed",
      "dafnyCode": "lemma CountBounded(ballots: seq<int>, c: int)\n  ensures Count(ballots, c) <= |ballots|\n{\n  if ballots != [] { CountBounded(ballots[1..], c); }\n}",
      "informalization": {
        "lemmaName": "CountBounded",
        "naturalLanguage": "For any sequence of ballots and any candidate, the count of votes for that candidate is at most the total number of ballots.",
        "preconditions": "None.",
        "postcondition": "Count(ballots, c) <= |ballots|",
        "scope": "A single state (any sequence of ballots and candidate).",
        "strength": "moderate",
        "confidence": 0.95
      },
      "comparison": {
        "requirementIndex": 0,
        "lemmaName": "CountBounded",
        "match": true,
        "discrepancy": "none",
        "weakeningType": "none",
        "explanation": "The back-translation correctly captures that the count of votes for any candidate cannot exceed the total number of ballots. The meaning is preserved exactly."
      },
      "index": 0,
      "expected": "confirmed"
    },
    {
      "requirement": "In an empty election with no ballots, every candidate has zero votes",
      "lemmaName": "EmptyElection",
      "status": "confirmed",
      "dafnyCode": "lemma EmptyElection(c: int)\n  ensures Count([], c) == 0\n{}",
      "informalization": {
        "lemmaName": "EmptyElection",
        "naturalLanguage": "For any candidate, the count of votes in an empty ballot sequence is zero.",
        "preconditions": "None.",
        "postcondition": "Count([], c) == 0",
        "scope": "A single state (the empty ballot sequence).",
        "strength": "trivial",
        "confidence": 0.98
      },
      "comparison": {
        "requirementIndex": 1,
        "lemmaName": "EmptyElection",
        "match": true,
        "discrepancy": "none",
        "weakeningType": "none",
        "explanation": "The back-translation correctly states that any candidate has zero votes in an empty ballot sequence. This matches the requirement that every candidate has zero votes in an empty election. The 'trivial' strength is appropriate here since the requirement itself is about a trivial base case."
      },
      "index": 1,
      "expected": "confirmed"
    },
    {
      "requirement": "A single ballot cast for a candidate gives that candidate exactly one vote",
      "lemmaName": "SingleBallotFor",
      "status": "confirmed",
      "dafnyCode": "lemma SingleBallotFor(c: int)\n  ensures Count([c], c) == 1\n{}",
      "informalization": {
        "lemmaName": "SingleBallotFor",
        "naturalLanguage": "For any candidate, a ballot sequence containing only that candidate receives exactly one vote for that candidate.",
        "preconditions": "None.",
        "postcondition": "Count([c], c) == 1",
        "scope": "A single state (a single-element ballot sequence).",
        "strength": "trivial",
        "confidence": 0.98
      },
      "comparison": {
        "requirementIndex": 2,
        "lemmaName": "SingleBallotFor",
        "match": true,
        "discrepancy": "none",
        "weakeningType": "none",
        "explanation": "The back-translation correctly captures that a single ballot for a candidate gives that candidate exactly one vote. The 'trivial' strength is appropriate for this simple base case requirement."
      },
      "index": 2,
      "expected": "confirmed"
    },
    {
      "requirement": "A single ballot cast for one candidate gives every other candidate zero votes",
      "lemmaName": "SingleBallotAgainst",
      "status": "confirmed",
      "dafnyCode": "lemma SingleBallotAgainst(c: int, other: int)\n  requires c != other\n  ensures Count([c], other) == 0\n{}",
      "informalization": {
        "lemmaName": "SingleBallotAgainst",
        "naturalLanguage": "For any two distinct candidates, a ballot sequence containing only the first candidate receives zero votes for the second candidate.",
        "preconditions": "c != other",
        "postcondition": "Count([c], other) == 0",
        "scope": "A single state (a single-element ballot sequence).",
        "strength": "trivial",
        "confidence": 0.98
      },
      "comparison": {
        "requirementIndex": 3,
        "lemmaName": "SingleBallotAgainst",
        "match": true,
        "discrepancy": "none",
        "weakeningType": "none",
        "explanation": "The back-translation correctly states that a ballot for one candidate gives zero votes to a different candidate. This matches the requirement about 'every other candidate' receiving zero votes (proven for any specific other candidate). The 'trivial' strength is appropriate for this simple case."
      },
      "index": 3,
      "expected": "confirmed"
    },
    {
      "requirement": "Casting a ballot for a candidate increases that candidate's tally by exactly one",
      "lemmaName": "VoteIncrement",
      "status": "confirmed",
      "dafnyCode": "lemma VoteIncrement(ballots: seq<int>, c: int)\n  ensures Count(ballots + [c], c) == Count(ballots, c) + 1\n{\n  if ballots != [] {\n    VoteIncrement(ballots[1..], c);\n    assert ballots + [c] == [ballots[0]] + (ballots[1..] + [c]);\n  }\n}",
      "informalization": {
        "lemmaName": "VoteIncrement",
        "naturalLanguage": "When a ballot for candidate c is appended to a ballot sequence, the count of votes for c increases by exactly one.",
        "preconditions": "None.",
        "postcondition": "Count(ballots + [c], c) == Count(ballots, c) + 1",
        "scope": "A transition from one ballot sequence to another (appending a ballot).",
        "strength": "strong",
        "confidence": 0.96
      },
      "comparison": {
        "requirementIndex": 4,
        "lemmaName": "VoteIncrement",
        "match": true,
        "discrepancy": "none",
        "weakeningType": "none",
        "explanation": "The back-translation correctly captures that appending a ballot for candidate c increases that candidate's count by exactly one. This matches the requirement about casting a ballot increasing the tally by exactly one."
      },
      "index": 4,
      "expected": "confirmed"
    },
    {
      "requirement": "Casting a ballot for one candidate does not change any other candidate's tally",
      "lemmaName": "VoteNoEffect",
      "status": "confirmed",
      "dafnyCode": "lemma VoteNoEffect(ballots: seq<int>, c: int, other: int)\n  requires c != other\n  ensures Count(ballots + [other], c) == Count(ballots, c)\n{\n  if ballots != [] {\n    VoteNoEffect(ballots[1..], c, other);\n    assert ballots + [other] == [ballots[0]] + (ballots[1..] + [other]);\n  }\n}",
      "informalization": {
        "lemmaName": "VoteNoEffect",
        "naturalLanguage": "When a ballot for a different candidate is appended to a ballot sequence, the count of votes for the original candidate remains unchanged.",
        "preconditions": "c != other",
        "postcondition": "Count(ballots + [other], c) == Count(ballots, c)",
        "scope": "A transition from one ballot sequence to another (appending a ballot for a different candidate).",
        "strength": "strong",
        "confidence": 0.96
      },
      "comparison": {
        "requirementIndex": 5,
        "lemmaName": "VoteNoEffect",
        "match": true,
        "discrepancy": "none",
        "weakeningType": "none",
        "explanation": "The back-translation correctly states that appending a ballot for one candidate does not change another candidate's count. This matches the requirement that casting a ballot for one candidate doesn't change other candidates' tallies."
      },
      "index": 5,
      "expected": "confirmed"
    },
    {
      "requirement": "Merging two ballot boxes produces a tally equal to the sum of the individual tallies",
      "lemmaName": "CombineTallies",
      "status": "confirmed",
      "dafnyCode": "lemma CombineTallies(a: seq<int>, b: seq<int>, c: int)\n  ensures Count(a + b, c) == Count(a, c) + Count(b, c)\n{\n  if a == [] {\n    assert a + b == b;\n  } else {\n    CombineTallies(a[1..], b, c);\n    assert a + b == [a[0]] + (a[1..] + b);\n  }\n}",
      "informalization": {
        "lemmaName": "CombineTallies",
        "naturalLanguage": "The count of votes for a candidate in the concatenation of two ballot sequences equals the sum of the counts in each sequence separately.",
        "preconditions": "None.",
        "postcondition": "Count(a + b, c) == Count(a, c) + Count(b, c)",
        "scope": "A single state (two ballot sequences and their concatenation).",
        "strength": "strong",
        "confidence": 0.96
      },
      "comparison": {
        "requirementIndex": 6,
        "lemmaName": "CombineTallies",
        "match": true,
        "discrepancy": "none",
        "weakeningType": "none",
        "explanation": "The back-translation correctly captures that concatenating two ballot sequences produces a count equal to the sum of individual counts. This matches the requirement about merging ballot boxes producing the sum of individual tallies."
      },
      "index": 6,
      "expected": "confirmed"
    },
    {
      "requirement": "The order in which ballots are counted does not affect the final tally",
      "lemmaName": "OrderIrrelevant",
      "status": "confirmed",
      "dafnyCode": "lemma OrderIrrelevant(a: seq<int>, b: seq<int>, c: int)\n  requires multiset(a) == multiset(b)\n  ensures Count(a, c) == Count(b, c)\n{\n  CountEqualsMultiplicity(a, c);\n  CountEqualsMultiplicity(b, c);\n}",
      "informalization": {
        "lemmaName": "OrderIrrelevant",
        "naturalLanguage": "If two ballot sequences contain the same multiset of ballots, they receive the same count of votes for any candidate.",
        "preconditions": "multiset(a) == multiset(b)",
        "postcondition": "Count(a, c) == Count(b, c)",
        "scope": "A single state (two ballot sequences with identical multisets).",
        "strength": "strong",
        "confidence": 0.94
      },
      "comparison": {
        "requirementIndex": 7,
        "lemmaName": "OrderIrrelevant",
        "match": true,
        "discrepancy": "none",
        "weakeningType": "none",
        "explanation": "The back-translation correctly states that two ballot sequences with the same multiset have the same count. This is the formal way to express that order doesn't affect the tally - if two sequences have the same elements (just reordered), they have the same multiset and thus the same count."
      },
      "index": 7,
      "expected": "confirmed"
    },
    {
      "requirement": "In a unanimous election, the winning candidate's tally equals the total number of ballots",
      "lemmaName": "UnanimousTally",
      "status": "confirmed",
      "dafnyCode": "lemma UnanimousTally(ballots: seq<int>, c: int)\n  requires forall i :: 0 <= i < |ballots| ==> ballots[i] == c\n  ensures Count(ballots, c) == |ballots|\n{\n  if ballots != [] { UnanimousTally(ballots[1..], c); }\n}",
      "informalization": {
        "lemmaName": "UnanimousTally",
        "naturalLanguage": "If all ballots in a sequence are for the same candidate, the count of votes for that candidate equals the total number of ballots.",
        "preconditions": "forall i :: 0 <= i < |ballots| ==> ballots[i] == c",
        "postcondition": "Count(ballots, c) == |ballots|",
        "scope": "A single state (a ballot sequence where all ballots are for one candidate).",
        "strength": "strong",
        "confidence": 0.96
      },
      "comparison": {
        "requirementIndex": 8,
        "lemmaName": "UnanimousTally",
        "match": true,
        "discrepancy": "none",
        "weakeningType": "none",
        "explanation": "The back-translation correctly captures that when all ballots are for the same candidate, that candidate's count equals the total number of ballots. This matches the requirement about unanimous elections."
      },
      "index": 8,
      "expected": "confirmed"
    },
    {
      "requirement": "In a unanimous election, every other candidate receives zero votes",
      "lemmaName": "UnanimousExclusion",
      "status": "confirmed",
      "dafnyCode": "lemma UnanimousExclusion(ballots: seq<int>, c: int, other: int)\n  requires forall i :: 0 <= i < |ballots| ==> ballots[i] == c\n  requires other != c\n  ensures Count(ballots, other) == 0\n{\n  if ballots != [] { UnanimousExclusion(ballots[1..], c, other); }\n}",
      "informalization": {
        "lemmaName": "UnanimousExclusion",
        "naturalLanguage": "If all ballots in a sequence are for one candidate, the count of votes for any different candidate is zero.",
        "preconditions": "forall i :: 0 <= i < |ballots| ==> ballots[i] == c; other != c",
        "postcondition": "Count(ballots, other) == 0",
        "scope": "A single state (a ballot sequence where all ballots are for one candidate).",
        "strength": "strong",
        "confidence": 0.96
      },
      "comparison": {
        "requirementIndex": 9,
        "lemmaName": "UnanimousExclusion",
        "match": true,
        "discrepancy": "none",
        "weakeningType": "none",
        "explanation": "The back-translation correctly states that when all ballots are for one candidate, any different candidate receives zero votes. This matches the requirement about every other candidate receiving zero votes in a unanimous election."
      },
      "index": 9,
      "expected": "confirmed"
    },
    {
      "requirement": "Adding a ballot to the election cannot cause any candidate's tally to decrease",
      "lemmaName": "TallyMonotonic",
      "status": "confirmed",
      "dafnyCode": "lemma TallyMonotonic(ballots: seq<int>, v: int, c: int)\n  ensures Count(ballots + [v], c) >= Count(ballots, c)\n{\n  if v == c { VoteIncrement(ballots, c); }\n  else      { VoteNoEffect(ballots, c, v); }\n}",
      "informalization": {
        "lemmaName": "TallyMonotonic",
        "naturalLanguage": "When any ballot is appended to a ballot sequence, the count of votes for any candidate is at least as large as before.",
        "preconditions": "None.",
        "postcondition": "Count(ballots + [v], c) >= Count(ballots, c)",
        "scope": "A transition from one ballot sequence to another (appending a ballot).",
        "strength": "strong",
        "confidence": 0.96
      },
      "comparison": {
        "requirementIndex": 10,
        "lemmaName": "TallyMonotonic",
        "match": true,
        "discrepancy": "none",
        "weakeningType": "none",
        "explanation": "The back-translation correctly captures that appending any ballot cannot decrease any candidate's count (it's at least as large as before). This matches the requirement that adding a ballot cannot cause tallies to decrease."
      },
      "index": 10,
      "expected": "confirmed"
    }
  ],
  "tokenUsage": {
    "input": 5933,
    "output": 2655
  }
}
