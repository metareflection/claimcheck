{
  "domain": "election0",
  "timestamp": "2026-02-15T16:14:05.197Z",
  "results": [
    {
      "requirement": "No candidate can receive more votes than the total number of ballots cast",
      "lemmaName": "CountBounded",
      "status": "confirmed",
      "dafnyCode": "lemma CountBounded(ballots: seq<int>, c: int)\n  ensures Count(ballots, c) <= |ballots|\n{\n  if ballots != [] { CountBounded(ballots[1..], c); }\n}",
      "informalization": {
        "lemmaName": "CountBounded",
        "naturalLanguage": "The count of ballots for any candidate is at most the total number of ballots.",
        "preconditions": "None.",
        "postcondition": "Count(ballots, c) <= |ballots|",
        "scope": "A single state (the given ballot sequence).",
        "strength": "moderate",
        "confidence": 0.95
      },
      "comparison": {
        "requirementIndex": 0,
        "lemmaName": "CountBounded",
        "match": true,
        "discrepancy": "none",
        "weakeningType": "none",
        "explanation": "The back-translation correctly captures that the count of ballots for any candidate is at most the total number of ballots, which is exactly what the requirement states."
      },
      "index": 0,
      "expected": "confirmed"
    },
    {
      "requirement": "In an empty election with no ballots, every candidate has zero votes",
      "lemmaName": "EmptyElection",
      "status": "confirmed",
      "dafnyCode": "lemma EmptyElection(c: int)\n  ensures Count([], c) == 0\n{}",
      "informalization": {
        "lemmaName": "EmptyElection",
        "naturalLanguage": "The count of votes for any candidate in an empty ballot sequence is zero.",
        "preconditions": "None.",
        "postcondition": "Count([], c) == 0",
        "scope": "A single state (the empty ballot sequence).",
        "strength": "trivial",
        "confidence": 0.98
      },
      "comparison": {
        "requirementIndex": 1,
        "lemmaName": "EmptyElection",
        "match": true,
        "discrepancy": "none",
        "weakeningType": "none",
        "explanation": "The back-translation correctly states that the count for any candidate in an empty ballot sequence is zero, matching the requirement. The 'trivial' strength is appropriate here since the requirement itself is trivial."
      },
      "index": 1,
      "expected": "confirmed"
    },
    {
      "requirement": "A single ballot cast for a candidate gives that candidate exactly one vote",
      "lemmaName": "SingleBallotFor",
      "status": "confirmed",
      "dafnyCode": "lemma SingleBallotFor(c: int)\n  ensures Count([c], c) == 1\n{}",
      "informalization": {
        "lemmaName": "SingleBallotFor",
        "naturalLanguage": "A single ballot cast for candidate c results in a count of 1 for that candidate.",
        "preconditions": "None.",
        "postcondition": "Count([c], c) == 1",
        "scope": "A single state (a ballot sequence containing one ballot).",
        "strength": "trivial",
        "confidence": 0.98
      },
      "comparison": {
        "requirementIndex": 2,
        "lemmaName": "SingleBallotFor",
        "match": true,
        "discrepancy": "none",
        "weakeningType": "none",
        "explanation": "The back-translation correctly captures that a single ballot for candidate c results in a count of 1 for that candidate, which matches the requirement exactly. The 'trivial' strength is appropriate for this simple case."
      },
      "index": 2,
      "expected": "confirmed"
    },
    {
      "requirement": "A single ballot cast for one candidate gives every other candidate zero votes",
      "lemmaName": "SingleBallotAgainst",
      "status": "confirmed",
      "dafnyCode": "lemma SingleBallotAgainst(c: int, other: int)\n  requires c != other\n  ensures Count([c], other) == 0\n{}",
      "informalization": {
        "lemmaName": "SingleBallotAgainst",
        "naturalLanguage": "A single ballot cast for candidate c results in a count of 0 for any other candidate.",
        "preconditions": "c != other",
        "postcondition": "Count([c], other) == 0",
        "scope": "A single state (a ballot sequence containing one ballot).",
        "strength": "trivial",
        "confidence": 0.98
      },
      "comparison": {
        "requirementIndex": 3,
        "lemmaName": "SingleBallotAgainst",
        "match": true,
        "discrepancy": "none",
        "weakeningType": "none",
        "explanation": "The back-translation correctly states that a single ballot for candidate c results in a count of 0 for any other candidate, which matches the requirement. The 'trivial' strength is appropriate for this simple case."
      },
      "index": 3,
      "expected": "confirmed"
    },
    {
      "requirement": "Casting a ballot for a candidate increases that candidate's tally by exactly one",
      "lemmaName": "VoteIncrement",
      "status": "confirmed",
      "dafnyCode": "lemma VoteIncrement(ballots: seq<int>, c: int)\n  ensures Count(ballots + [c], c) == Count(ballots, c) + 1\n{\n  if ballots != [] {\n    VoteIncrement(ballots[1..], c);\n    assert ballots + [c] == [ballots[0]] + (ballots[1..] + [c]);\n  }\n}",
      "informalization": {
        "lemmaName": "VoteIncrement",
        "naturalLanguage": "Adding a ballot for candidate c to a ballot sequence increases the count for c by exactly 1.",
        "preconditions": "None.",
        "postcondition": "Count(ballots + [c], c) == Count(ballots, c) + 1",
        "scope": "A transition from one ballot sequence to another (appending a ballot).",
        "strength": "strong",
        "confidence": 0.96
      },
      "comparison": {
        "requirementIndex": 4,
        "lemmaName": "VoteIncrement",
        "match": true,
        "discrepancy": "none",
        "weakeningType": "none",
        "explanation": "The back-translation correctly captures that adding a ballot for candidate c increases the count for c by exactly 1, which matches the requirement's intent about casting a ballot increasing the tally by exactly one."
      },
      "index": 4,
      "expected": "confirmed"
    },
    {
      "requirement": "Casting a ballot for one candidate does not change any other candidate's tally",
      "lemmaName": "VoteNoEffect",
      "status": "confirmed",
      "dafnyCode": "lemma VoteNoEffect(ballots: seq<int>, c: int, other: int)\n  requires c != other\n  ensures Count(ballots + [other], c) == Count(ballots, c)\n{\n  if ballots != [] {\n    VoteNoEffect(ballots[1..], c, other);\n    assert ballots + [other] == [ballots[0]] + (ballots[1..] + [other]);\n  }\n}",
      "informalization": {
        "lemmaName": "VoteNoEffect",
        "naturalLanguage": "Adding a ballot for a different candidate does not change the count for candidate c.",
        "preconditions": "c != other",
        "postcondition": "Count(ballots + [other], c) == Count(ballots, c)",
        "scope": "A transition from one ballot sequence to another (appending a ballot for a different candidate).",
        "strength": "strong",
        "confidence": 0.96
      },
      "comparison": {
        "requirementIndex": 5,
        "lemmaName": "VoteNoEffect",
        "match": true,
        "discrepancy": "none",
        "weakeningType": "none",
        "explanation": "The back-translation correctly states that adding a ballot for a different candidate does not change the count for candidate c, which matches the requirement that casting a ballot for one candidate doesn't change other candidates' tallies."
      },
      "index": 5,
      "expected": "confirmed"
    },
    {
      "requirement": "Merging two ballot boxes produces a tally equal to the sum of the individual tallies",
      "lemmaName": "CombineTallies",
      "status": "confirmed",
      "dafnyCode": "lemma CombineTallies(a: seq<int>, b: seq<int>, c: int)\n  ensures Count(a + b, c) == Count(a, c) + Count(b, c)\n{\n  if a == [] {\n    assert a + b == b;\n  } else {\n    CombineTallies(a[1..], b, c);\n    assert a + b == [a[0]] + (a[1..] + b);\n  }\n}",
      "informalization": {
        "lemmaName": "CombineTallies",
        "naturalLanguage": "The count of votes for candidate c in the concatenation of two ballot sequences equals the sum of the counts in each sequence.",
        "preconditions": "None.",
        "postcondition": "Count(a + b, c) == Count(a, c) + Count(b, c)",
        "scope": "A single state (two ballot sequences and their concatenation).",
        "strength": "strong",
        "confidence": 0.97
      },
      "comparison": {
        "requirementIndex": 6,
        "lemmaName": "CombineTallies",
        "match": true,
        "discrepancy": "none",
        "weakeningType": "none",
        "explanation": "The back-translation correctly captures that the count in the concatenation of two ballot sequences equals the sum of counts in each sequence, which matches the requirement about merging ballot boxes producing a sum of individual tallies."
      },
      "index": 6,
      "expected": "confirmed"
    },
    {
      "requirement": "The order in which ballots are counted does not affect the final tally",
      "lemmaName": "OrderIrrelevant",
      "status": "disputed",
      "dafnyCode": "lemma OrderIrrelevant(ballots: seq<int>, v: int, c: int)\n  ensures Count([v] + ballots, c) == Count(ballots + [v], c)\n{\n  CombineTallies([v], ballots, c);\n  CombineTallies(ballots, [v], c);\n}",
      "informalization": {
        "lemmaName": "OrderIrrelevant",
        "naturalLanguage": "Prepending a ballot for candidate v to a sequence produces the same count as appending it, for any candidate c.",
        "preconditions": "None.",
        "postcondition": "Count([v] + ballots, c) == Count(ballots + [v], c)",
        "scope": "A single state (a ballot sequence with a ballot prepended versus appended).",
        "strength": "moderate",
        "confidence": 0.95
      },
      "comparison": {
        "requirementIndex": 7,
        "lemmaName": "OrderIrrelevant",
        "match": false,
        "discrepancy": "The lemma only proves that prepending versus appending a single ballot produces the same count, but the requirement asks for a general statement that the order in which ballots are counted doesn't affect the final tally. This should apply to arbitrary permutations of the ballot sequence, not just moving one ballot from front to back.",
        "weakeningType": "narrowed-scope",
        "explanation": "The requirement implies that any reordering of ballots should produce the same tally, but the lemma only proves a very specific case (prepending vs appending a single ballot). This is a much narrower scope than what the requirement asks for."
      },
      "discrepancy": "The lemma only proves that prepending versus appending a single ballot produces the same count, but the requirement asks for a general statement that the order in which ballots are counted doesn't affect the final tally. This should apply to arbitrary permutations of the ballot sequence, not just moving one ballot from front to back.",
      "weakeningType": "narrowed-scope",
      "index": 7,
      "expected": "confirmed"
    },
    {
      "requirement": "In a unanimous election, the winning candidate's tally equals the total number of ballots",
      "lemmaName": "UnanimousTally",
      "status": "confirmed",
      "dafnyCode": "lemma UnanimousTally(ballots: seq<int>, c: int)\n  requires forall i :: 0 <= i < |ballots| ==> ballots[i] == c\n  ensures Count(ballots, c) == |ballots|\n{\n  if ballots != [] { UnanimousTally(ballots[1..], c); }\n}",
      "informalization": {
        "lemmaName": "UnanimousTally",
        "naturalLanguage": "If all ballots in a sequence are for candidate c, then the count for c equals the total number of ballots.",
        "preconditions": "All ballots in the sequence are for candidate c (forall i :: 0 <= i < |ballots| ==> ballots[i] == c).",
        "postcondition": "Count(ballots, c) == |ballots|",
        "scope": "A single state (a ballot sequence where all ballots are identical).",
        "strength": "strong",
        "confidence": 0.97
      },
      "comparison": {
        "requirementIndex": 8,
        "lemmaName": "UnanimousTally",
        "match": true,
        "discrepancy": "none",
        "weakeningType": "none",
        "explanation": "The back-translation correctly captures that if all ballots are for candidate c, then the count for c equals the total number of ballots, which matches the requirement about unanimous elections."
      },
      "index": 8,
      "expected": "confirmed"
    },
    {
      "requirement": "In a unanimous election, every other candidate receives zero votes",
      "lemmaName": "UnanimousExclusion",
      "status": "confirmed",
      "dafnyCode": "lemma UnanimousExclusion(ballots: seq<int>, c: int, other: int)\n  requires forall i :: 0 <= i < |ballots| ==> ballots[i] == c\n  requires other != c\n  ensures Count(ballots, other) == 0\n{\n  if ballots != [] { UnanimousExclusion(ballots[1..], c, other); }\n}",
      "informalization": {
        "lemmaName": "UnanimousExclusion",
        "naturalLanguage": "If all ballots in a sequence are for candidate c, then the count for any other candidate is zero.",
        "preconditions": "All ballots in the sequence are for candidate c (forall i :: 0 <= i < |ballots| ==> ballots[i] == c), and other != c.",
        "postcondition": "Count(ballots, other) == 0",
        "scope": "A single state (a ballot sequence where all ballots are identical).",
        "strength": "strong",
        "confidence": 0.97
      },
      "comparison": {
        "requirementIndex": 9,
        "lemmaName": "UnanimousExclusion",
        "match": true,
        "discrepancy": "none",
        "weakeningType": "none",
        "explanation": "The back-translation correctly states that if all ballots are for candidate c, then any other candidate has a count of zero, which matches the requirement about unanimous elections and other candidates receiving zero votes."
      },
      "index": 9,
      "expected": "confirmed"
    },
    {
      "requirement": "Adding ballots can't decrease a tally",
      "lemmaName": "TallyMonotonic",
      "status": "disputed",
      "dafnyCode": "lemma TallyMonotonic(ballots: seq<int>, v: int, c: int)\n  ensures Count(ballots + [v], c) >= 0\n{}",
      "informalization": {
        "lemmaName": "TallyMonotonic",
        "naturalLanguage": "The count of votes for any candidate after appending a ballot is non-negative.",
        "preconditions": "None.",
        "postcondition": "Count(ballots + [v], c) >= 0",
        "scope": "A single state (a ballot sequence with an appended ballot).",
        "strength": "trivial",
        "confidence": 0.9
      },
      "comparison": {
        "requirementIndex": 10,
        "lemmaName": "TallyMonotonic",
        "match": false,
        "discrepancy": "The requirement states that adding ballots can't decrease a tally, which means Count(ballots + [v], c) >= Count(ballots, c). However, the lemma only ensures Count(ballots + [v], c) >= 0, which is a much weaker statement that just says the count is non-negative. This doesn't capture the monotonicity property at all.",
        "weakeningType": "weakened-postcondition",
        "explanation": "The lemma proves that counts are non-negative (which is trivially true), but the requirement asks for monotonicity - that adding ballots doesn't decrease the existing tally. The back-translation's 'trivial' strength is a red flag that this doesn't capture the requirement's intent."
      },
      "discrepancy": "The requirement states that adding ballots can't decrease a tally, which means Count(ballots + [v], c) >= Count(ballots, c). However, the lemma only ensures Count(ballots + [v], c) >= 0, which is a much weaker statement that just says the count is non-negative. This doesn't capture the monotonicity property at all.",
      "weakeningType": "weakened-postcondition",
      "index": 10,
      "expected": "confirmed"
    }
  ],
  "tokenUsage": {
    "input": 5819,
    "output": 2794
  }
}
